<!--
SINGLE-FILE HTML RULE: All code, styles, and assets must be embedded in this file.
MODULARITY RULE: Build features in a modular, maintainable way. Avoid bloat and conflicting code.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Glittercloud Adventure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body { height: 100%; margin: 0; padding: 0; background: #181818; }
    body { width: 100vw; height: 100vh; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
    #game-container { position: relative; width: 100vw; height: 100vh; }
    #game-canvas { width: 100%; height: 100%; background: #222; display: block; }
    #hud { position: absolute; top: 10px; left: 10px; color: #fff; z-index: 10; }
    #start-overlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: url('https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GlitterStart-eWtnNjTcWxXyheoQtPcBK9MDLQWYBK.png?koxn') center center/cover no-repeat;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      z-index: 1000;
      transition: opacity 0.3s;
    }
    #start-overlay.hidden { opacity: 0; pointer-events: none; }
    #start-content {
      margin-top: 50vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
      transform: translateY(-50%);
    }
    #start-title {
      font-size: 2.6em;
      font-family: 'Monoton', 'Courier New', monospace;
      text-align: center;
      color: #edd628;
      text-shadow: 0 0 7px #9932cc, 0 0 10px #9932cc, 0 0 21px #9932cc, 0 0 42px #9932cc;
      margin-bottom: 12px;
      letter-spacing: 2px;
      animation: glow 2s ease-in-out infinite alternate;
    }
    #start-btn {
      background: linear-gradient(135deg, rgba(153,50,204,0.8) 0%, rgba(153,50,204,0.4) 100%);
      border: 2px solid #9932cc;
      color: #edd628;
      font-family: 'Courier New', monospace;
      font-size: 1.3em;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 10px #000, 0 0 20px #000, 0 0 30px #9932cc;
      box-shadow: 0 0 20px rgba(153,50,204,0.5);
      border-radius: 25px;
      min-width: 200px;
      text-align: center;
      padding: 15px 30px;
      outline: none;
      margin-bottom: 24px;
      animation: buttonPulse 2s infinite;
    }
    #start-btn:hover {
      background: linear-gradient(135deg, rgba(153,50,204,1) 0%, rgba(153,50,204,0.6) 100%);
      transform: scale(1.05);
      text-shadow: 0 0 20px #000, 0 0 30px #000, 0 0 40px #9932cc;
      box-shadow: 0 0 30px rgba(153,50,204,0.7);
    }
    #start-credit {
      color: #fff;
      font-size: 0.9em;
      opacity: 0.7;
      text-shadow: 1px 1px 8px #000;
    }
    /* Cutscene Styles */
    #cutscene-overlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      display: none;
      z-index: 2000;
    }
    #cutscene-bg {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background-size: cover;
      background-position: center;
      opacity: 1;
      z-index: 0;
      transition: background-image 0.6s;
    }
    #cutscene-textbox {
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      width: 100vw;
      max-width: 100vw;
      height: 35vh;
      min-height: unset;
      max-height: 35vh;
      overflow-y: auto;
      background: rgba(0,0,0,0.85);
      box-shadow: 0 -4px 32px #000a;
      border-top-left-radius: 24px;
      border-top-right-radius: 24px;
      padding: 24px 32px 16px 32px;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
    }
    #cutscene-text {
      color: #0ff;
      font-family: 'Courier New', monospace;
      font-size: 1.25em;
      text-align: left;
      width: 100%;
      max-width: 900px;
      min-height: 2.5em;
      margin: 0 auto 12px auto;
      text-shadow: 2px 2px 8px #000;
      letter-spacing: 0.5px;
      line-height: 1.3;
      opacity: 1;
      transition: opacity 0.3s;
      word-break: break-word;
    }
    #cutscene-text.galaxander {
      font-size: 0.95em;
    }
    #cutscene-skip {
      color: #0ff;
      font-size: 1em;
      opacity: 0.7;
      margin-top: 8px;
      animation: pulse 1.5s infinite;
      user-select: none;
      text-align: right;
      width: 100%;
      max-width: 900px;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 0.3; }
      100% { opacity: 0.7; }
    }
    @keyframes glow {
      from {
        text-shadow: 0 0 7px #9932cc, 0 0 10px #9932cc, 0 0 21px #9932cc, 0 0 42px #9932cc;
      }
      to {
        text-shadow: 0 0 10px #9932cc, 0 0 20px #9932cc, 0 0 30px #9932cc, 0 0 50px #9932cc;
      }
    }
    @keyframes buttonPulse {
      0% {
        box-shadow: 0 0 20px rgba(153,50,204,0.5);
      }
      50% {
        box-shadow: 0 0 30px rgba(153,50,204,0.7);
      }
      100% {
        box-shadow: 0 0 20px rgba(153,50,204,0.5);
      }
    }
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    @keyframes fadeInOut {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      20% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      80% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
    }
    /* --- Menu Overlay Styles (inspired by gcaworking.html, clean version) --- */
    #menu-overlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.95);
      z-index: 3000;
      display: none;
      font-family: 'Luminari', 'Georgia', serif;
    }
    #menu-overlay.open {
      display: flex !important;
    }
    #menu-content {
      background: rgba(0,0,0,0.97);
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff44;
      color: #00ffff;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 24px;
      border-bottom: 2px solid #00ffff44;
      background: rgba(0,255,255,0.05);
    }
    .menu-title {
      font-size: 1.4em;
      color: #fff;
      text-shadow: 0 0 10px #00ffff;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .menu-party-nav {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
    }
    .menu-party-nav button {
      background: none;
      border: none;
      color: #00ffff;
      cursor: pointer;
      font-size: 1.2em;
      padding: 4px 8px;
      transition: all 0.2s;
    }
    .menu-party-nav button:hover {
      color: #fff;
      text-shadow: 0 0 10px #00ffff;
    }
    .menu-close-btn {
      background: none;
      border: none;
      color: #00ffff;
      font-size: 1.5em;
      cursor: pointer;
      transition: all 0.2s;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      margin: 0;
      line-height: 1;
    }
    .menu-close-btn:hover {
      color: #fff;
      text-shadow: 0 0 15px #00ffff;
      transform: scale(1.1);
    }
    .menu-content-wrapper {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .menu-main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 24px;
      gap: 16px;
    }
    .menu-sidebar {
      width: 300px;
      border-left: 2px solid #00ffff44;
      background: rgba(0,255,255,0.03);
      padding: 24px;
      overflow-y: auto;
    }
    .menu-card {
      background: rgba(0,255,255,0.05);
      border: 1px solid #00ffff44;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .menu-card-title {
      color: #fff;
      font-size: 1.2em;
      margin-bottom: 12px;
      text-shadow: 0 0 10px #00ffff;
    }
    .menu-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .menu-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      background: rgba(0,255,255,0.03);
      border-radius: 4px;
    }
    .menu-stat-label {
      color: #fff;
      opacity: 0.8;
    }
    .menu-stat-value {
      color: #00ffff;
      font-weight: bold;
    }
    .menu-progress-bar {
      height: 8px;
      background: rgba(0,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
      margin: 4px 0;
    }
    .menu-progress-fill {
      height: 100%;
      background: #00ffff;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    .menu-tabs {
      display: flex;
      width: 100%;
      border-top: 2px solid #00ffff44;
      background: rgba(0,255,255,0.03);
      margin: 0;
      padding: 0;
      font-size: 0.95em;
      gap: 0;
      justify-content: space-between;
    }
    .menu-tab-btn {
      flex: 1;
      background: none;
      border: none;
      color: #00ffff;
      padding: 10px 4px;
      font-size: 0.95em;
      cursor: pointer;
      text-align: center;
      border-top: 2px solid transparent;
      transition: all 0.2s;
      outline: none;
      min-width: 0;
      letter-spacing: 0.01em;
    }
    .menu-tab-btn:hover {
      background: rgba(0,255,255,0.1);
    }
    .menu-tab-btn.active {
      border-top: 2px solid #00ffff;
      color: #fff;
      background: rgba(0,255,255,0.15);
      text-shadow: 0 0 10px #00ffff;
    }
    .menu-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .menu-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(0,255,255,0.03);
      border: 1px solid #00ffff22;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .menu-list-item:hover {
      background: rgba(0,255,255,0.08);
      border-color: #00ffff44;
    }
    .menu-list-item.selected {
      background: rgba(0,255,255,0.15);
      border-color: #00ffff;
    }
    .menu-detail {
      background: rgba(0,255,255,0.05);
      border: 1px solid #00ffff44;
      border-radius: 8px;
      padding: 16px;
    }
    .menu-detail-title {
      color: #fff;
      font-size: 1.2em;
      margin-bottom: 12px;
      text-shadow: 0 0 10px #00ffff;
    }
    .menu-detail-content {
      color: #00ffff;
      line-height: 1.4;
    }
    .menu-item-use-btn {
      background: rgba(0,255,255,0.2);
      border: 1px solid #00ffff;
      color: #fff;
      padding: 2px 10px;
      font-size: 0.85em;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .menu-item-use-btn:hover {
      background: rgba(0,255,255,0.4);
      transform: scale(1.05);
    }
    @media (max-width: 600px) {
      #menu-content { min-width: 90vw; min-height: 60vh; padding: 0; }
      .menu-tab-content { padding: 10px 6px 0 6px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="640" height="480"></canvas>
    <div id="hud">Glittercloud Adventure</div>
    <div id="start-overlay">
      <div id="start-content">
        <div id="start-title">Glitter Cloud Adventure</div>
        <button id="start-btn">Start Game</button>
        <div id="start-credit">© Galaxander Corp. All Rights Reserved.</div>
      </div>
    </div>
    <!-- Cutscene Overlay -->
    <div id="cutscene-overlay">
      <div id="cutscene-bg"></div>
      <div id="cutscene-textbox">
        <div id="cutscene-text"></div>
        <div id="cutscene-skip">Press any key or click to skip</div>
      </div>
    </div>
    <div id="menu-overlay">
      <div id="menu-content">
        <div class="menu-header">
          <div class="menu-title">
            <span>Menu</span>
            <div class="menu-party-nav">
              <button class="prev-party">◄</button>
              <span class="menu-party-name">[Alex]</span>
              <button class="next-party">►</button>
              <span class="menu-party-count">1/3 Members</span>
            </div>
          </div>
          <button class="menu-close-btn" id="menu-close-btn" title="Close">×</button>
        </div>
        <div class="menu-content-wrapper">
          <div class="menu-main-content">
            <!-- Character Tab -->
            <div class="menu-tab-content" id="menu-tab-character">
              <div class="menu-card">
                <div class="menu-card-title">Character Info</div>
                <div class="menu-stats-grid">
                  <div class="menu-stat">
                    <span class="menu-stat-label">Level</span>
                    <span class="menu-stat-value">5</span>
                  </div>
                  <div class="menu-stat">
                    <span class="menu-stat-label">Class</span>
                    <span class="menu-stat-value">Flexecutioner</span>
                  </div>
                  <div class="menu-stat">
                    <span class="menu-stat-label">XP</span>
                    <span class="menu-stat-value">1200/1500</span>
                  </div>
                </div>
                <div class="menu-progress-bar">
                  <div class="menu-progress-fill" style="width: ${(player.experience / player.experienceToNextLevel) * 100}%"></div>
                </div>
              </div>
              <div class="menu-card">
                <div class="menu-card-title">Vitals</div>
                <div class="menu-stats-grid">
                  <div class="menu-stat">
                    <span class="menu-stat-label">HP</span>
                    <span class="menu-stat-value">${player.hp}/${player.maxHp}</span>
                  </div>
                  <div class="menu-stat">
                    <span class="menu-stat-label">MP</span>
                    <span class="menu-stat-value">${player.mp}/${player.maxMp}</span>
                  </div>
                </div>
                <div class="menu-progress-bar">
                  <div class="menu-progress-fill" style="width: ${(player.hp / player.maxHp) * 100}%"></div>
                </div>
                <div class="menu-progress-bar">
                  <div class="menu-progress-fill" style="width: ${(player.mp / player.maxMp) * 100}%"></div>
                </div>
              </div>
            </div>
            <!-- Other tabs will be populated dynamically -->
            <div class="menu-tab-content" id="menu-tab-inventory" style="display:none"></div>
            <div class="menu-tab-content" id="menu-tab-skills" style="display:none"></div>
            <div class="menu-tab-content" id="menu-tab-equipment" style="display:none"></div>
            <div class="menu-tab-content" id="menu-tab-relics" style="display:none"></div>
            <div class="menu-tab-content" id="menu-tab-party" style="display:none"></div>
            <div class="menu-tab-content" id="menu-tab-quests" style="display:none"></div>
            <div class="menu-tab-content" id="menu-tab-settings" style="display:none"></div>
          </div>
          <div class="menu-sidebar">
            <div class="menu-detail">
              <div class="menu-detail-title">Selected Item</div>
              <div class="menu-detail-content">
                Select an item to view details
              </div>
            </div>
          </div>
        </div>
        <div class="menu-tabs">
          <button class="menu-tab-btn active" data-tab="character">Character</button>
          <button class="menu-tab-btn" data-tab="inventory">Inventory</button>
          <button class="menu-tab-btn" data-tab="skills">Skills</button>
          <button class="menu-tab-btn" data-tab="equipment">Equipment</button>
          <button class="menu-tab-btn" data-tab="relics">Relics</button>
          <button class="menu-tab-btn" data-tab="party">Party</button>
          <button class="menu-tab-btn" data-tab="quests">Quests</button>
          <button class="menu-tab-btn" data-tab="settings">Settings</button>
        </div>
      </div>
    </div>
    <div id="debug-overlay" style="display:none; position:fixed; top:0; right:0; width:340px; max-width:100vw; height:100vh; background:rgba(0,0,0,0.92); color:#0ff; z-index:9999; font-size:0.95em; font-family:monospace; overflow-y:auto; pointer-events:auto; border-left:2px solid #0ff;">
      <div style="padding:8px 12px; border-bottom:1px solid #0ff; display:flex; justify-content:space-between; align-items:center;">
        <span><b>Debug Overlay</b></span>
        <button id="debug-close-btn" style="background:none; border:none; color:#0ff; font-size:1.2em; cursor:pointer;">×</button>
      </div>
      <div id="debug-content" style="padding:10px;"></div>
    </div>
  </div>
  <script>
    // SINGLE-FILE HTML RULE: All code is embedded here.
    // MODULARITY RULE: Use classes and clear structure.

    // --- Game Constants ---
    const TILE_SIZE = 32;
    const MAP_WIDTH = 20;
    const MAP_HEIGHT = 15;
    const GAME_WIDTH = TILE_SIZE * MAP_WIDTH;
    const GAME_HEIGHT = TILE_SIZE * MAP_HEIGHT;

    // --- Enemy Types & Weaknesses ---
    const ENEMY_TYPES = {
      BUG: { weaknesses: ['fire'], resistances: ['poison'] },
      CONSTRUCT: { weaknesses: ['lightning'], resistances: [], nulls: ['charm'] },
      BEAST: { weaknesses: ['ice'], resistances: ['earth'] },
      MYSTIC: { weaknesses: ['holy'], resistances: ['dark'] },
      AQUATIC: { weaknesses: ['lightning'], resistances: ['water', 'ice'] }
    };

    // --- Enemy Data (from B1: Digital Dawn) ---
    const ENEMY_DATABASE = {
      'roach': {
        name: 'Roach',
        level: 1,
        type: 'BUG',
        hp: { min: 27, max: 50 },
        mp: 10,
        stats: {
          attack: { min: 4, max: 8 },
          defense: { min: 2, max: 3 },
          magic: { min: 1, max: 2 },
          mDefense: { min: 1, max: 2 },
          speed: { min: 8, max: 12 },
          luck: { min: 5, max: 8 }
        },
        abilities: [
          { name: 'Nibble', type: 'physical', power: 0.8, description: 'Light physical damage' },
          { name: 'Scuttle', type: 'buff', effect: 'evasion', duration: 1, description: 'Increases evasion for 1 turn' }
        ],
        drops: [
          { item: 'Bug Shell', chance: 100, quantity: 1 },
          { item: 'Sticky Residue', chance: 30, quantity: 1 },
          { item: 'Shiny Object', chance: 5, quantity: 1 }
        ],
        xp: { min: 10, max: 20 },
        gold: { min: 5, max: 15 },
        description: "Pesky digital vermin that multiply in the dark corners of the net."
      },
      'spamton': {
        name: 'Spamton',
        level: 1,
        type: 'CONSTRUCT',
        hp: { min: 35, max: 70 },
        mp: 15,
        stats: {
          attack: { min: 3, max: 6 },
          defense: { min: 3, max: 5 },
          magic: { min: 5, max: 8 },
          mDefense: { min: 4, max: 6 },
          speed: { min: 6, max: 10 },
          luck: { min: 10, max: 15 }
        },
        abilities: [
          { name: 'Special Offer', type: 'status', effect: 'confuse', chance: 30, description: 'May confuse target' },
          { name: 'Bulk Discount', type: 'magical', power: 0.6, targetAll: true, description: 'Light damage to all' },
          { name: 'Limited Time', type: 'buff', effect: 'attack', power: 1.3, duration: 3, description: 'Increases ATK' }
        ],
        drops: [
          { item: 'Spam Mail', chance: 100, quantity: 1 },
          { item: 'Coupon', chance: 25, quantity: 1 },
          { item: 'Golden Ticket', chance: 10, quantity: 1 }
        ],
        xp: { min: 10, max: 20 },
        gold: { min: 5, max: 15 },
        description: "A living advertisement that won't take no for an answer."
      },
      'wifi_yeti': {
        name: 'WiFi Yeti',
        level: 2,
        type: 'BEAST',
        hp: { min: 45, max: 90 },
        mp: 20,
        stats: {
          attack: { min: 5, max: 10 },
          defense: { min: 2, max: 4 },
          magic: { min: 3, max: 6 },
          mDefense: { min: 1, max: 3 },
          speed: { min: 4, max: 8 },
          luck: { min: 5, max: 10 }
        },
        abilities: [
          { name: 'Icy Claw', type: 'physical', power: 1.2, element: 'ice', statusChance: 20, status: 'freeze' },
          { name: 'Signal Jam', type: 'debuff', effect: 'accuracy', power: 0.7, targetAll: true },
          { name: 'Hibernate', type: 'heal', power: 0.2, skipTurn: true }
        ],
        drops: [
          { item: 'Yeti Fur', chance: 100, quantity: 1 },
          { item: 'Frost Shard', chance: 35, quantity: 1 },
          { item: 'Frozen Core', chance: 10, quantity: 1 }
        ],
        xp: { min: 15, max: 25 },
        gold: { min: 10, max: 20 },
        description: "A hulking beast that feeds on weak signals and slower connections."
      }
    };

    // --- Enemy Class ---
    class Enemy {
      constructor(enemyId, level = null) {
        const data = ENEMY_DATABASE[enemyId];
        if (!data) throw new Error(`Unknown enemy: ${enemyId}`);
        
        this.id = `enemy_${Date.now()}_${Math.floor(Math.random()*10000)}`;
        this.enemyId = enemyId;
        this.name = data.name;
        this.level = level || data.level;
        this.type = data.type;
        this.description = data.description;
        
        // Roll HP/MP within ranges
        this.hp = Math.floor(Math.random() * (data.hp.max - data.hp.min + 1)) + data.hp.min;
        this.maxHp = this.hp;
        this.mp = data.mp;
        this.maxMp = data.mp;
        
        // Roll stats within ranges
        this.stats = {};
        for (const stat in data.stats) {
          const range = data.stats[stat];
          this.stats[stat] = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        }
        
        // Copy abilities, drops, rewards
        this.abilities = [...data.abilities];
        this.drops = data.drops;
        this.xpReward = Math.floor(Math.random() * (data.xp.max - data.xp.min + 1)) + data.xp.min;
        this.goldReward = Math.floor(Math.random() * (data.gold.max - data.gold.min + 1)) + data.gold.min;
        
        // Combat state
        this.statusEffects = [];
        this.buffs = [];
        this.debuffs = [];
        this.actionCooldowns = {};
      }
      
      takeDamage(damage, damageType = 'physical', element = null) {
        let finalDamage = damage;
        
        // Apply type weaknesses/resistances
        const typeData = ENEMY_TYPES[this.type];
        if (element && typeData) {
          if (typeData.weaknesses.includes(element)) {
            finalDamage *= 1.5; // 50% more damage
          } else if (typeData.resistances.includes(element)) {
            finalDamage *= 0.5; // 50% less damage
          }
        }
        
        // Apply defense
        if (damageType === 'physical') {
          finalDamage *= (100 / (100 + this.stats.defense));
        } else if (damageType === 'magical') {
          finalDamage *= (100 / (100 + this.stats.mDefense));
        }
        
        finalDamage = Math.floor(finalDamage);
        this.hp = Math.max(0, this.hp - finalDamage);
        
        return { damage: finalDamage, weakness: element && typeData?.weaknesses.includes(element) };
      }
      
      chooseAction(party) {
        // Simple AI: choose random available ability
        const availableAbilities = this.abilities.filter(ability => {
          const cooldown = this.actionCooldowns[ability.name] || 0;
          return cooldown === 0;
        });
        
        if (availableAbilities.length === 0) {
          // Basic attack if no abilities available
          return { type: 'attack', target: this.selectTarget(party) };
        }
        
        const ability = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
        const targets = ability.targetAll ? party : [this.selectTarget(party)];
        
        return { type: 'ability', ability, targets };
      }
      
      selectTarget(party) {
        // Simple targeting: pick random alive party member
        const alive = party.filter(member => member.hp > 0);
        return alive[Math.floor(Math.random() * alive.length)];
      }
      
      rollDrops() {
        const dropped = [];
        for (const drop of this.drops) {
          if (Math.random() * 100 < drop.chance) {
            dropped.push({
              item: drop.item,
              quantity: drop.quantity || 1
            });
          }
        }
        return dropped;
      }
    }

    // --- Cutscene System ---
    class CutsceneManager {
      constructor(onFinish) {
        this.overlay = document.getElementById('cutscene-overlay');
        this.bgElem = document.getElementById('cutscene-bg');
        this.textElem = document.getElementById('cutscene-text');
        this.skipElem = document.getElementById('cutscene-skip');
        this.onFinish = onFinish;
        this.current = null;
        this.index = 0;
        this.timeout = null;
        this.skipped = false;
        this.typingTimeout = null;
        this.typewriterSpeed = 22; // ms per char
        this.handleSkip = this.handleSkip.bind(this);
      }
      play(cutscene) {
        this.current = cutscene;
        this.index = 0;
        this.skipped = false;
        this.overlay.style.display = 'block';
        this.textElem.textContent = '';
        this.bgElem.style.opacity = '1';
        document.getElementById('start-overlay').style.display = 'none';
        setTimeout(() => this.nextScene(), 100);
        window.addEventListener('keydown', this.handleSkip);
        window.addEventListener('mousedown', this.handleSkip);
        window.addEventListener('touchstart', this.handleSkip);
      }
      nextScene() {
        if (!this.current || this.index >= this.current.length || this.skipped) {
          this.end();
          return;
        }
        const scene = this.current[this.index];
        if (scene.background) {
          this.bgElem.style.backgroundImage = `url('${scene.background}')`;
        } else {
          this.bgElem.style.backgroundImage = '';
        }
        this.textElem.textContent = '';
        this.textElem.className = '';
        if (scene.text.includes('Galaxander')) {
          this.textElem.classList.add('galaxander');
        }
        this._typeText(scene.text, 0, () => {
          this.timeout = setTimeout(() => {
            this.index++;
            this.nextScene();
          }, scene.duration);
        });
      }
      _typeText(text, i, done) {
        if (this.skipped) return;
        if (i <= text.length) {
          this.textElem.textContent = text.slice(0, i);
          this.typingTimeout = setTimeout(() => this._typeText(text, i + 1, done), this.typewriterSpeed);
        } else {
          done();
        }
      }
      handleSkip() {
        this.skipped = true;
        this.end();
      }
      end() {
        clearTimeout(this.timeout);
        clearTimeout(this.typingTimeout);
        this.overlay.style.display = 'none';
        this.textElem.textContent = '';
        this.bgElem.style.backgroundImage = '';
        window.removeEventListener('keydown', this.handleSkip);
        window.removeEventListener('mousedown', this.handleSkip);
        window.removeEventListener('touchstart', this.handleSkip);
        document.getElementById('start-overlay').style.display = 'flex';
        if (this.onFinish) this.onFinish();
      }
    }

    // Update the introCutscene array to include all scenes from the original introscene in gcaworking.html
    const introCutscene = [
      {
        text: "We had no idea Earth was for sale.\nUntil we were purchased by the interstellar version of P.T. Barnum",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Narrative1-q2mDBsKvyqQsNn7Zu7a3QT36p2M9hh.png?vGuq",
        duration: 2000
      },
      {
        text: "It was just a normal day on Earth. People were grocery shopping. Picking up their kids. Scrolling. Swiping. Swearing at traffic.",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Shopping-58EG1CsWpUH7RBPY3jXTyyxBdLrCm1.png?SMlF",
        duration: 2000
      },
      {
        text: "A piercing PING! erupts from every screen—phones, billboards, smart‑watches—halting seven billion heartbeats in unison.",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Shock-FE8GYBHDyJ1NXFS6vDl4O6K36GIVA1.png?pZxF",
        duration: 2000
      },
      {
        text: "The message repeats in every language as panic sparks.",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Auction-DD4H0eTvXmUDImg5FIuH8a8bPot7Xq.png?0KdN",
        duration: 2000
      },
      {
        text: "Shafts of electric light skewer the streets; citizens are digitized mid‑stride and whisked skyward in shimmering data‑streams.",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/TeleportStore-o52yEto3qZbwQuZkZmi2RlKjTaXsaE.png?wblu",
        duration: 2000
      },
      {
        text: "In transit, bodies recompile—jeans into neon jumpsuits, flesh into pixel‑sheened avatars—stats and health bars flickering overhead.",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Transformation-BzVmMb5tmkizSnIxX5rDDqv5YnvKF7.png?mppc",
        duration: 2000
      },
      {
        text: "Humanity rematerializes inside a boundless, zero‑G arcade. Cabinets ignite, revealing the grinning visage of Galaxander: 'Welcome, contestants! Your planet has been acquired by the Galaxander Corporation and all of you now star in the ultimate intergalactic game show.'",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/ArcadeWelcomeAnime-HTgSCgK8bb5l026TEsrtvxLs2WoovU.png?ixZi",
        duration: 2500
      },
      {
        text: "Alarms blare. Prize hatches on every claw machine burst open, spewing goblins that swarm the floor—Level One has begun.",
        background: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Firrstfight-k99DrfTi1srSIFLGPo0tqI0oX2neX3.png?32eu",
        duration: 2000
      }
    ];

    // --- Map System ---
    class GameMap {
      constructor() {
        // 0 = floor, 1 = wall
        this.grid = Array.from({length: MAP_HEIGHT}, (_, y) =>
          Array.from({length: MAP_WIDTH}, (_, x) =>
            (x === 0 || y === 0 || x === MAP_WIDTH-1 || y === MAP_HEIGHT-1) ? 1 : 0
          )
        );
        // Add some interior walls
        this.grid[5][5] = 1; this.grid[5][6] = 1;
        this.grid[6][5] = 1; this.grid[6][6] = 1;
        this.grid[8][10] = 1; this.grid[9][10] = 1;
        
        // Add spawn zones for enemies
        this.enemySpawnZones = [
          { x: 10, y: 7, radius: 3, enemyTypes: ['roach', 'spamton'] },
          { x: 15, y: 12, radius: 2, enemyTypes: ['wifi_yeti'] }
        ];
        
        // Track enemy encounters
        this.enemies = [];
        this.spawnEnemies();
      }
      
      spawnEnemies() {
        // Spawn some enemies in zones
        for (const zone of this.enemySpawnZones) {
          const numEnemies = 2 + Math.floor(Math.random() * 2);
          for (let i = 0; i < numEnemies; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * zone.radius;
            const x = zone.x + Math.cos(angle) * dist;
            const y = zone.y + Math.sin(angle) * dist;
            
            const enemyType = zone.enemyTypes[Math.floor(Math.random() * zone.enemyTypes.length)];
            this.enemies.push({
              x: Math.floor(x),
              y: Math.floor(y),
              type: enemyType,
              engaged: false,
              id: `map_enemy_${Date.now()}_${Math.floor(Math.random()*1000)}`
            });
          }
        }
      }
      
      checkEnemyEncounter(playerX, playerY) {
        const px = Math.floor(playerX / TILE_SIZE);
        const py = Math.floor(playerY / TILE_SIZE);
        
        for (const enemy of this.enemies) {
          if (!enemy.engaged && enemy.x === px && enemy.y === py) {
            enemy.engaged = true;
            return enemy;
          }
        }
        return null;
      }
      
      isWall(x, y) {
        return this.grid[y] && this.grid[y][x] === 1;
      }
      
      render(ctx) {
        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            if (this.grid[y][x] === 1) {
              ctx.fillStyle = '#444';
              ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else {
              ctx.fillStyle = '#222';
              ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
            ctx.strokeStyle = '#333';
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
        
        // Render enemies
        ctx.fillStyle = '#f44';
        for (const enemy of this.enemies) {
          if (!enemy.engaged) {
            ctx.fillRect(enemy.x * TILE_SIZE + 8, enemy.y * TILE_SIZE + 8, TILE_SIZE - 16, TILE_SIZE - 16);
          }
        }
      }
    }

    // --- Class Data (from gcaworking.html) ---
    const CLASSES = {
      ASPIRING: {
        name: "Aspiring",
        vitToHpMult: 5,
        intToMpMult: 3,
        strToAtkMult: 1,
        vitToDefMult: 0.5,
        dexToSpdMult: 1,
        baseGrowth: {
          strength: 1,
          vitality: 1,
          dexterity: 1,
          intelligence: 1,
          luck: 1,
          charisma: 1,
          fortune: 1
        },
        skillProgression: {}
      },
      FLEXECUTIONER: {
        name: "Flexecutioner",
        vitToHpMult: 7,
        intToMpMult: 2,
        strToAtkMult: 1.2,
        vitToDefMult: 0.7,
        dexToSpdMult: 0.7,
        baseGrowth: {
          strength: 1.2,
          vitality: 1.0,
          dexterity: 0.7,
          intelligence: 0.4,
          luck: 0.5,
          charisma: 0.6,
          fortune: 0.5
        },
        skillProgression: {
          1: [{ name: "Power Strike", type: "active", mpCost: 5, cooldown: 3, description: "220% STR damage. 20% chance to Bleed (10% HP over 3 turns)." }],
          3: [{ name: "Protein Shake", type: "passive", mpCost: 0, cooldown: 0, description: "+4% max HP & +5% HP regen in overworld" }],
          5: [{ name: "Swole Stomp", type: "active", mpCost: 10, cooldown: 5, description: "Powerful AoE with stun chance." }]
        }
      },
      RIZZLER: {
        name: "Rizzler",
        vitToHpMult: 4,
        intToMpMult: 5,
        strToAtkMult: 0.4,
        vitToDefMult: 0.6,
        dexToSpdMult: 0.8,
        baseGrowth: {
          strength: 0.4,
          vitality: 0.6,
          dexterity: 0.8,
          intelligence: 1.0,
          luck: 0.7,
          charisma: 1.2,
          fortune: 0.7
        },
        skillProgression: {
          1: [{ name: "Charm", type: "active", mpCost: 4, cooldown: 2, description: "Chance to confuse enemy." }],
          3: [{ name: "Viral Post", type: "active", mpCost: 8, cooldown: 4, description: "AoE debuff, lowers enemy defense." }],
          5: [{ name: "Trendsetter", type: "passive", mpCost: 0, cooldown: 0, description: "Party-wide buff to speed." }]
        }
      },
      "SUS-ASSASSIN": {
        name: "Sus-Assassin",
        vitToHpMult: 5,
        intToMpMult: 3,
        strToAtkMult: 0.8,
        vitToDefMult: 0.7,
        dexToSpdMult: 1.2,
        baseGrowth: {
          strength: 0.8,
          vitality: 0.7,
          dexterity: 1.2,
          intelligence: 0.5,
          luck: 1.0,
          charisma: 0.8,
          fortune: 1.0
        },
        skillProgression: {
          1: [{ name: "Backstab", type: "active", mpCost: 6, cooldown: 3, description: "High crit chance attack." }],
          3: [{ name: "Shadowmeld", type: "active", mpCost: 8, cooldown: 5, description: "Become untargetable for 1 turn." }],
          5: [{ name: "Perfect Precision", type: "passive", mpCost: 0, cooldown: 0, description: "5% chance for attacks to ignore defense." }]
        }
      },
      INFLUMANCER: {
        name: "Influmancer",
        vitToHpMult: 3,
        intToMpMult: 7,
        strToAtkMult: 0.3,
        vitToDefMult: 0.5,
        dexToSpdMult: 0.7,
        baseGrowth: {
          strength: 0.3,
          vitality: 0.5,
          dexterity: 0.7,
          intelligence: 1.2,
          luck: 0.9,
          charisma: 1.0,
          fortune: 0.9
        },
        skillProgression: {
          1: [{ name: "Hype Wave", type: "active", mpCost: 7, cooldown: 3, description: "Party-wide heal." }],
          3: [{ name: "Trending", type: "passive", mpCost: 0, cooldown: 0, description: "Status effects last 2 turns longer." }],
          5: [{ name: "Reality Administrator", type: "passive", mpCost: 0, cooldown: 0, description: "15% chance for spells to cost 0 MP." }]
        }
      }
    };

    // --- Skill Structure ---
    // { name, type, mpCost, cooldown, description, unlocked (bool), levelUnlocked }

    // --- Character System ---
    class Character {
      constructor(options = {}) {
        // Core identity
        this.id = options.id || `char_${Date.now()}_${Math.floor(Math.random()*10000)}`;
        this.name = options.name || "Player";
        this.class = options.class || "ASPIRING";
        this.level = options.level || 1;
        this.experience = options.experience || 0;
        this.experienceToNextLevel = options.experienceToNextLevel || 100;
        this.prestigeLevel = options.prestigeLevel || 0;
        this.prestigeTalent = options.prestigeTalent || null;
        this.prestigeAura = options.prestigeAura || null;
        this.createdAt = options.createdAt || Date.now();
        this.lastPlayed = options.lastPlayed || Date.now();

        // Stats & attributes
        this.stats = Object.assign({
          strength: 10,
          dexterity: 10,
          vitality: 10,
          intelligence: 10,
          luck: 10,
          charisma: 10,
          fortune: 10
        }, options.stats);
        this.baseStats = Object.assign({}, this.stats);
        this.derivedStats = options.derivedStats || {};
        this.statPoints = options.statPoints || 0;
        this.skillPoints = options.skillPoints || 0;
        this.hp = options.hp || 100;
        this.maxHp = options.maxHp || 100;
        this.mp = options.mp || 30;
        this.maxMp = options.maxMp || 30;
        this.gold = options.gold || 0;

        // Progression
        this.pendingClassSelection = options.pendingClassSelection || false;
        this.availablePoints = options.availablePoints || 0;
        this.statsLocked = options.statsLocked || false;

        // Skills & abilities
        this.skills = options.skills || [];
        this.spells = options.spells || [];
        this.passives = options.passives || [];
        this.masteredSkills = options.masteredSkills || [];
        this.pendingSkillNotifications = options.pendingSkillNotifications || [];

        // Equipment & inventory
        this.equipment = Object.assign({
          MAIN_HAND: null,
          OFF_HAND: null,
          HEAD: null,
          BODY: null,
          LEGS: null,
          FEET: null,
          RELIC_1: null,
          RELIC_2: null
        }, options.equipment);
        this.inventory = options.inventory || [];

        // Party & relationships
        this.relationships = options.relationships || {};
        this.partyOrder = options.partyOrder || 0;
        this.partyActive = options.partyActive !== undefined ? options.partyActive : true;

        // Status & effects
        this.statusEffects = options.statusEffects || [];
        this.effects = options.effects || [];

        // Cosmic powers
        this.cosmicPowers = options.cosmicPowers || [];
        this.cosmicBalance = options.cosmicBalance || { harmony: 0, chaos: 0, stability: 0 };
        this.cosmicCombos = options.cosmicCombos || [];

        // Type mastery & achievements
        this.typeMastery = options.typeMastery || {};
        this.achievements = options.achievements || [];

        // Quests & story
        this.quests = options.quests || { active: [], completed: [] };
        this.questStates = options.questStates || {};
        this.storylinePosition = options.storylinePosition || { chapter: 1, scene: 1, flags: {} };

        // Relics
        this.relics = options.relics || {};
        this.fury = options.fury || 0;
        this.masteredRelicSkills = options.masteredRelicSkills || [];

        // Animation state
        this.sprite = options.sprite || null;
        this.direction = options.direction || "down";
        this.frame = options.frame || 0;
        this.animationState = options.animationState || { isIdle: true };

        this.calculateDerivedStats();
        this.initSkills();
      }
      initSkills() {
        // Unlock skills for current level
        const classData = CLASSES[this.class] || CLASSES.ASPIRING;
        this.skills = [];
        for (const lvl in classData.skillProgression) {
          if (this.level >= parseInt(lvl)) {
            for (const skill of classData.skillProgression[lvl]) {
              this.skills.push({ ...skill, unlocked: true, levelUnlocked: parseInt(lvl) });
            }
          }
        }
      }
      calculateDerivedStats() {
        const classData = CLASSES[this.class] || CLASSES.ASPIRING;
        this.derivedStats = {
          maxHp: Math.floor(10 + (this.stats.vitality * (classData.vitToHpMult || 5)) + (this.level * 2)),
          maxMp: Math.floor(5 + (this.stats.intelligence * (classData.intToMpMult || 3)) + this.level),
          attack: Math.floor(this.stats.strength * (classData.strToAtkMult || 1)),
          defense: Math.floor(this.stats.vitality * (classData.vitToDefMult || 0.5)),
          speed: Math.floor(this.stats.dexterity * (classData.dexToSpdMult || 1)),
          critChance: Math.min(5 + Math.floor(this.stats.fortune / 4), 30),
          evasion: Math.min(Math.floor(this.stats.dexterity / 2), 25)
        };
        // Sync HP/MP if needed
        if (!this.hp || this.hp > this.derivedStats.maxHp) this.hp = this.derivedStats.maxHp;
        if (!this.mp || this.mp > this.derivedStats.maxMp) this.mp = this.derivedStats.maxMp;
        this.maxHp = this.derivedStats.maxHp;
        this.maxMp = this.derivedStats.maxMp;
      }
      gainExperience(amount) {
        this.experience += amount;
        while (this.experience >= this.experienceToNextLevel) {
          this.experience -= this.experienceToNextLevel;
          this.levelUp();
        }
      }
      levelUp() {
        this.level += 1;
        // Class-based stat growth
        const classData = CLASSES[this.class] || CLASSES.ASPIRING;
        for (const stat in classData.baseGrowth) {
          if (this.stats[stat] !== undefined) {
            this.stats[stat] += classData.baseGrowth[stat];
          }
        }
        this.experienceToNextLevel = Math.floor(100 * Math.pow(1.5, this.level - 1));
        
        // Give stat points for manual allocation
        this.statPoints += 3; // 3 stat points per level
        
        // Full heal on level up
        this.calculateDerivedStats();
        this.hp = this.maxHp;
        this.mp = this.maxMp;
        
        // Unlock new skills if available
        this.initSkills();
        
        // Class advancement at level 5
        if (this.level === 5 && this.class === "ASPIRING") {
          this.pendingClassSelection = true;
        }
        
        // Prestige at level 80
        if (this.level === 80) {
          this.prestige();
        }
      }
      prestige() {
        // Prestige: reset to level 1, retain skills/mastery, stat retention, assign talent
        this.prestigeLevel = (this.prestigeLevel || 0) + 1;
        // Retain 10% of stats
        for (const stat in this.stats) {
          this.stats[stat] = Math.floor(this.stats[stat] * 0.1);
          this.baseStats[stat] = this.stats[stat];
        }
        this.level = 1;
        this.experience = 0;
        this.experienceToNextLevel = 100;
        this.prestigeAura = true;
        // Retain all mastered skills
        this.masteredSkills = [...this.skills];
        // Assign prestige talent based on class
        const talents = {
          FLEXECUTIONER: "Limitless Gains",
          RIZZLER: "Endless Charisma",
          "SUS-ASSASSIN": "Perfect Precision",
          INFLUMANCER: "Reality Administrator"
        };
        this.prestigeTalent = talents[this.class] || null;
        this.calculateDerivedStats();
      }
    }

    // --- Player Entity ---
    class Player {
      constructor(x, y, map) {
        // Use Character for all player data
        this.character = new Character({
          name: "Hazel",
          portraitFrames: [
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/02734c7f-ee83-4cb8-a785-4c5b9b9e62fc/Jump_1-EHd6aTym2GZYG9YGUObU4C3UVzRM4J.png?yK6e",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/02734c7f-ee83-4cb8-a785-4c5b9b9e62fc/Jump_2-TIKd2Ng5h3f2XtIzD5OYUfmvwMcgCQ.png?9Lx1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/02734c7f-ee83-4cb8-a785-4c5b9b9e62fc/Jump_2-TIKd2Ng5h3f2XtIzD5OYUfmvwMcgCQ.png?9Lx1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/02734c7f-ee83-4cb8-a785-4c5b9b9e62fc/Jump_4-gSm4PyttYHunekRzEFgIHAKnZQDwfA.png?9b67",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/02734c7f-ee83-4cb8-a785-4c5b9b9e62fc/Jump_5-FZ0aZQXgDbESB4PHVg49uHFLt0LmT0.png?7Y1S"
          ],
          class: "ASPIRING",
          level: 1,
          experience: 0,
          stats: {
            strength: 10,
            dexterity: 10,
            vitality: 10,
            intelligence: 10,
            luck: 10,
            charisma: 10,
            fortune: 10
          },
          hp: 100,
          maxHp: 100,
          mp: 30,
          maxMp: 30,
          gold: 0,
          sprite: null,
          direction: "down",
          frame: 0
        });
        
        // Make character methods available on player for convenience
        this.gainExperience = (amount) => this.character.gainExperience(amount);
        
        this.x = x;
        this.y = y;
        this.size = TILE_SIZE;
        this.color = '#0ff';
        this.speed = 200;
        this.keys = {};
        this.map = map;
        this.stepsSinceLastEncounter = 0;
      }
      
      handleKey(key, isDown) {
        this.keys[key.toLowerCase()] = isDown;
      }
      
      update(dt) {
        let dx = 0, dy = 0;
        let moved = false;
        
        if (this.keys['arrowup'] || this.keys['w']) { dy -= 1; moved = true; }
        if (this.keys['arrowdown'] || this.keys['s']) { dy += 1; moved = true; }
        if (this.keys['arrowleft'] || this.keys['a']) { dx -= 1; moved = true; }
        if (this.keys['arrowright'] || this.keys['d']) { dx += 1; moved = true; }
        
        if (dx !== 0 && dy !== 0) { dx *= Math.SQRT1_2; dy *= Math.SQRT1_2; }
        
        let newX = this.x + dx * this.speed * dt;
        let newY = this.y + dy * this.speed * dt;
        
        // Collision detection
        if (!this.collides(newX, this.y)) this.x = newX;
        if (!this.collides(this.x, newY)) this.y = newY;
        
        // Clamp to map
        this.x = Math.max(0, Math.min(GAME_WIDTH - this.size, this.x));
        this.y = Math.max(0, Math.min(GAME_HEIGHT - this.size, this.y));
        
        // Track steps for random encounters
        if (moved) {
          this.stepsSinceLastEncounter++;
        }
      }
      
      collides(x, y) {
        // Check all four corners
        const corners = [
          [x, y],
          [x + this.size - 1, y],
          [x, y + this.size - 1],
          [x + this.size - 1, y + this.size - 1]
        ];
        for (const [cx, cy] of corners) {
          const tx = Math.floor(cx / TILE_SIZE);
          const ty = Math.floor(cy / TILE_SIZE);
          if (this.map.isWall(tx, ty)) return true;
        }
        return false;
      }
      
      render(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    // --- HUD ---
    function updateHUD(player) {
      let hud = document.getElementById('hud');
      if (!hud) return;
      const c = player.character;
      hud.innerHTML = `
        <b>${c.name}</b> (Lv.${c.level}${c.prestigeLevel > 0 ? '★'.repeat(c.prestigeLevel) : ''}) ${c.class}<br>
        HP: ${c.hp} / ${c.maxHp} &nbsp; MP: ${c.mp} / ${c.maxMp}<br>
        STR: ${c.stats.strength} &nbsp; DEX: ${c.stats.dexterity} &nbsp; VIT: ${c.stats.vitality} &nbsp; INT: ${c.stats.intelligence}<br>
        ATK: ${c.derivedStats.attack} &nbsp; DEF: ${c.derivedStats.defense} &nbsp; SPD: ${c.derivedStats.speed}<br>
        CRIT: ${c.derivedStats.critChance}% &nbsp; EVA: ${c.derivedStats.evasion}%<br>
        Gold: ${c.gold} &nbsp; XP: ${c.experience}/${c.experienceToNextLevel}
        ${c.statPoints > 0 ? `<br><b style="color:#ff0;">Stat Points Available: ${c.statPoints}</b>` : ''}
      `;
    }

    // --- Game Engine ---
    class Game {
      constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.lastTime = 0;
        this.map = new GameMap();
        this.player = new Player(2 * TILE_SIZE, 2 * TILE_SIZE, this.map);
        this.combatSystem = new CombatSystem(this);
        this.questManager = new QuestManager();
        this.inCombat = false;
        
        // Create Glitch NPC
        this.glitch = new GlitchNPC(5, 2);
        this.map.npcs = [this.glitch];
        
        this.bindEvents();
        
        // Make systems globally accessible for UI
        window.combatSystem = this.combatSystem;
        window.questManager = this.questManager;
        
        // Give player some starting items
        this.player.character.addItem('potion', 3);
        
        requestAnimationFrame(this.loop.bind(this));
      }
      
      bindEvents() {
        window.addEventListener('keydown', e => {
          if (!this.inCombat) {
            this.player.handleKey(e.key, true);
            
            // Check for NPC interaction
            if (e.key === 'e' || e.key === 'Enter') {
              this.checkNPCInteraction();
            }
          }
        });
        window.addEventListener('keyup', e => {
          if (!this.inCombat) {
            this.player.handleKey(e.key, false);
          }
        });
      }
      
      checkNPCInteraction() {
        const px = Math.floor(this.player.x / TILE_SIZE);
        const py = Math.floor(this.player.y / TILE_SIZE);
        
        // Check if player is adjacent to Glitch
        const dx = Math.abs(px - this.glitch.x);
        const dy = Math.abs(py - this.glitch.y);
        
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
          this.glitch.interact();
        }
      }
      
      loop(ts) {
        const dt = (ts - this.lastTime) / 1000;
        this.lastTime = ts;
        
        if (!this.inCombat) {
          this.update(dt);
          this.render();
        }
        
        updateHUD(this.player);
        requestAnimationFrame(this.loop.bind(this));
      }
      
      update(dt) {
        this.player.update(dt);
        
        // Check for enemy encounters
        const encounter = this.map.checkEnemyEncounter(this.player.x, this.player.y);
        if (encounter) {
          this.startCombat([encounter.type]);
        }
        
        // Random encounters
        if (this.player.stepsSinceLastEncounter > 50 && Math.random() < 0.02) {
          this.player.stepsSinceLastEncounter = 0;
          const randomEnemies = ['roach', 'spamton', 'wifi_yeti'];
          const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
          this.startCombat([enemyType]);
        }
      }
      
      startCombat(enemyTypes) {
        this.inCombat = true;
        this.combatSystem.startCombat([this.player.character], enemyTypes);
      }
      
      resumeFromCombat() {
        this.inCombat = false;
        // Reset player keys
        this.player.keys = {};
      }
      
      render() {
        this.ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        this.map.render(this.ctx);
        
        // Render NPCs
        this.ctx.fillStyle = '#ff0';
        this.ctx.fillRect(this.glitch.x * TILE_SIZE + 4, this.glitch.y * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);
        this.ctx.fillStyle = '#000';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('G', this.glitch.x * TILE_SIZE + TILE_SIZE/2, this.glitch.y * TILE_SIZE + TILE_SIZE/2 + 4);
        
        // Render player
        this.player.render(this.ctx);
        
        // Show interaction hint if near NPC
        const px = Math.floor(this.player.x / TILE_SIZE);
        const py = Math.floor(this.player.y / TILE_SIZE);
        const dx = Math.abs(px - this.glitch.x);
        const dy = Math.abs(py - this.glitch.y);
        
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
          this.ctx.fillStyle = '#fff';
          this.ctx.font = '10px Arial';
          this.ctx.textAlign = 'center';
          this.ctx.fillText('[E] Talk', this.player.x + TILE_SIZE/2, this.player.y - 5);
        }
      }
    }

    // --- MenuManager ---
    class MenuManager {
      constructor() {
        this.overlay = document.getElementById('menu-overlay');
        this.tabs = Array.from(document.querySelectorAll('.menu-tab-btn'));
        this.tabContents = {
          character: document.getElementById('menu-tab-character'),
          inventory: document.getElementById('menu-tab-inventory'),
          skills: document.getElementById('menu-tab-skills'),
          equipment: document.getElementById('menu-tab-equipment'),
          relics: document.getElementById('menu-tab-relics'),
          party: document.getElementById('menu-tab-party'),
          quests: document.getElementById('menu-tab-quests'),
          settings: document.getElementById('menu-tab-settings')
        };
        this.closeBtn = document.getElementById('menu-close-btn');
        this.activeTab = 'character';
        this.selectedItem = null;
        this.partyIndex = 0;
        this.partyMembers = [];
        this._bindEvents();
      }

      _bindEvents() {
        this.closeBtn.onclick = () => this.close();
        this.tabs.forEach(tab => {
          tab.onclick = () => this.switchTab(tab.dataset.tab);
        });
        document.querySelector('.prev-party').onclick = () => this.cycleParty(-1);
        document.querySelector('.next-party').onclick = () => this.cycleParty(1);
        window.addEventListener('keydown', e => {
          if (e.key === 'Escape') this.close();
          if (e.key === 'ArrowLeft') this.cycleParty(-1);
          if (e.key === 'ArrowRight') this.cycleParty(1);
        });
      }

      open() {
        this.overlay.classList.add('open');
        this.switchTab(this.activeTab);
        this.updatePartyNav();
      }

      close() {
        this.overlay.classList.remove('open');
      }

      switchTab(tab) {
        this.activeTab = tab;
        this.tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
        Object.keys(this.tabContents).forEach(key => {
          this.tabContents[key].style.display = (key === tab) ? '' : 'none';
        });
        this.renderTab(tab);
      }

      cycleParty(direction) {
        if (!this.partyMembers.length) return;
        this.partyIndex = (this.partyIndex + direction + this.partyMembers.length) % this.partyMembers.length;
        this.updatePartyNav();
        this.renderTab(this.activeTab);
      }

      updatePartyNav() {
        const nav = document.querySelector('.menu-party-nav');
        if (!nav) return;
        const member = this.partyMembers[this.partyIndex] || { name: 'None' };
        const nameSpan = nav.querySelector('.menu-party-name');
        const countSpan = nav.querySelector('.menu-party-count');
        if (nameSpan) nameSpan.textContent = `[${member.name}]`;
        if (countSpan) countSpan.textContent = `${this.partyIndex + 1}/${this.partyMembers.length} Members`;
      }

      selectItem(item) {
        this.selectedItem = item;
        const detailContent = document.querySelector('.menu-detail-content');
        if (!detailContent) return;
        
        if (!item) {
          detailContent.innerHTML = 'Select an item to view details';
          return;
        }

        detailContent.innerHTML = `
          <h3>${item.name}</h3>
          ${item.description ? `<p>${item.description}</p>` : ''}
          ${item.stats ? `
            <div class="menu-stats-grid">
              ${Object.entries(item.stats).map(([key, value]) => `
                <div class="menu-stat">
                  <span class="menu-stat-label">${key}</span>
                  <span class="menu-stat-value">${value}</span>
                </div>
              `).join('')}
            </div>
          ` : ''}
        `;
      }

      renderTab(tab) {
        const player = window.game?.player?.character;
        if (!player) return;

        switch(tab) {
          case 'character':
            this.tabContents.character.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Character Info</div>
                <div class="menu-stats-grid">
                  <div class="menu-stat">
                    <span class="menu-stat-label">Level</span>
                    <span class="menu-stat-value">${player.level}</span>
                  </div>
                  <div class="menu-stat">
                    <span class="menu-stat-label">Class</span>
                    <span class="menu-stat-value">${player.class}</span>
                  </div>
                  <div class="menu-stat">
                    <span class="menu-stat-label">XP</span>
                    <span class="menu-stat-value">${player.experience}/${player.experienceToNextLevel}</span>
                  </div>
                </div>
                <div class="menu-progress-bar">
                  <div class="menu-progress-fill" style="width: ${(player.experience / player.experienceToNextLevel) * 100}%"></div>
                </div>
              </div>
              <div class="menu-card">
                <div class="menu-card-title">Vitals</div>
                <div class="menu-stats-grid">
                  <div class="menu-stat">
                    <span class="menu-stat-label">HP</span>
                    <span class="menu-stat-value">${player.hp}/${player.maxHp}</span>
                  </div>
                  <div class="menu-stat">
                    <span class="menu-stat-label">MP</span>
                    <span class="menu-stat-value">${player.mp}/${player.maxMp}</span>
                  </div>
                </div>
                <div class="menu-progress-bar">
                  <div class="menu-progress-fill" style="width: ${(player.hp / player.maxHp) * 100}%"></div>
                </div>
                <div class="menu-progress-bar">
                  <div class="menu-progress-fill" style="width: ${(player.mp / player.maxMp) * 100}%"></div>
                </div>
              </div>
            `;
            break;

          case 'inventory':
            this.tabContents.inventory.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Inventory</div>
                <div class="menu-list">
                  ${player.inventory.length > 0 
                    ? player.inventory.map((item, idx) => {
                        const itemData = ITEM_DATABASE[item.id];
                        const isConsumable = itemData && itemData.type === 'consumable';
                        return `
                          <div class="menu-list-item" onclick="menuManager.selectItem(window.menuManager.partyMembers[window.menuManager.partyIndex].inventory[${idx}])">
                            <span>${item.name} ${item.quantity > 1 ? `x${item.quantity}` : ''}</span>
                            <span>
                              ${isConsumable ? `<button class="menu-item-use-btn" onclick="event.stopPropagation(); menuManager.useItem('${item.id}')">Use</button>` : ''}
                            </span>
                          </div>
                        `;
                      }).join('')
                    : '<div class="menu-list-item">No items in inventory</div>'
                  }
                </div>
              </div>
            `;
            break;

          case 'skills':
            this.tabContents.skills.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Active Skills</div>
                <div class="menu-list">
                  ${player.skills.filter(s => s.type === 'active').length > 0
                    ? player.skills.filter(s => s.type === 'active').map((skill, idx) => `
                        <div class="menu-list-item" onclick="menuManager.selectItem(window.menuManager.partyMembers[window.menuManager.partyIndex].skills.filter(s=>s.type==='active')[${idx}])">
                          <span>${skill.name} ${skill.levelUnlocked ? `(Lv.${skill.levelUnlocked})` : ''}</span>
                          <span>MP: ${skill.mpCost}</span>
                        </div>
                      `).join('')
                    : '<div class="menu-list-item">No active skills learned yet</div>'
                  }
                </div>
              </div>
              <div class="menu-card">
                <div class="menu-card-title">Passive Skills</div>
                <div class="menu-list">
                  ${player.skills.filter(s => s.type === 'passive').length > 0
                    ? player.skills.filter(s => s.type === 'passive').map((skill, idx) => `
                        <div class="menu-list-item" onclick="menuManager.selectItem(window.menuManager.partyMembers[window.menuManager.partyIndex].skills.filter(s=>s.type==='passive')[${idx}])">
                          <span>${skill.name} ${skill.levelUnlocked ? `(Lv.${skill.levelUnlocked})` : ''}</span>
                          <span>Passive</span>
                        </div>
                      `).join('')
                    : '<div class="menu-list-item">No passive skills learned yet</div>'
                  }
                </div>
              </div>
            `;
            break;

          case 'equipment':
            this.tabContents.equipment.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Equipment</div>
                <div class="menu-list">
                  ${Object.entries(player.equipment).map(([slot, item], idx) => `
                    <div class="menu-list-item" onclick="menuManager.selectItem(window.menuManager.partyMembers[window.menuManager.partyIndex].equipment['${slot}'])">
                      <span>${slot.replace(/_/g, ' ')}</span>
                      <span>${item ? item.name : 'Empty'}</span>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
            break;

          case 'relics':
            this.tabContents.relics.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Relics</div>
                <div class="menu-list">
                  ${Object.values(player.relics).length > 0
                    ? Object.values(player.relics).map((relic, idx) => `
                        <div class="menu-list-item" onclick="menuManager.selectItem(window.menuManager.partyMembers[window.menuManager.partyIndex].relics[Object.keys(window.menuManager.partyMembers[window.menuManager.partyIndex].relics)[${idx}]])">
                          <span>${relic.name} ${player.equipment.RELIC_1 === relic || player.equipment.RELIC_2 === relic ? '(Equipped)' : ''}</span>
                          <span>Lv.${relic.level} (${relic.xp}/${relic.xpToNextLevel} XP)</span>
                        </div>
                      `).join('')
                    : '<div class="menu-list-item">No relics owned</div>'
                  }
                </div>
                ${player.fury > 0 ? `<div style="margin-top: 10px; color: #f44;">Fury: ${player.fury}</div>` : ''}
              </div>
            `;
            break;

          case 'party':
            this.tabContents.party.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Party Members</div>
                <div class="menu-list">
                  <div class="menu-list-item selected">
                    <span>${player.name}</span>
                    <span>Lv.${player.level} ${player.class}</span>
                  </div>
                  ${Object.entries(player.relationships).map(([name, rel]) => `
                    <div class="menu-list-item">
                      <span>${name}</span>
                      <span>Relationship: ${rel.level}</span>
                    </div>
                  `).join('')}
                </div>
              </div>
              <div class="menu-card">
                <div class="menu-card-title">Party Formation</div>
                <div style="text-align: center; color: #888; padding: 20px;">
                  Formation system coming soon!
                </div>
              </div>
            `;
            break;

          case 'quests':
            const questManager = window.questManager;
            this.tabContents.quests.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Active Quests</div>
                <div class="menu-list">
                  ${questManager && questManager.activeQuests.length > 0 
                    ? questManager.activeQuests.map((quest, idx) => {
                        const progress = quest.objectives.reduce((acc, obj) => acc + (obj.current / obj.required), 0) / quest.objectives.length * 100;
                        return `
                          <div class="menu-list-item" onclick="menuManager.selectQuest(${idx})">
                            <span>${quest.name}</span>
                            <span>${Math.floor(progress)}%</span>
                          </div>
                        `;
                      }).join('')
                    : '<div class="menu-list-item">No active quests</div>'
                  }
                </div>
              </div>
              <div class="menu-card">
                <div class="menu-card-title">Completed Quests</div>
                <div class="menu-list">
                  ${questManager && questManager.completedQuests.length > 0 
                    ? questManager.completedQuests.map((quest, idx) => `
                        <div class="menu-list-item" onclick="menuManager.selectCompletedQuest(${idx})">
                          <span>${quest.name}</span>
                          <span>✓</span>
                        </div>
                      `).join('')
                    : '<div class="menu-list-item">No completed quests</div>'
                  }
                </div>
              </div>
            `;
            break;

          case 'settings':
            this.tabContents.settings.innerHTML = `
              <div class="menu-card">
                <div class="menu-card-title">Game Settings</div>
                <div class="menu-list">
                  <div class="menu-list-item">
                    <span>Master Volume</span>
                    <span>[Coming Soon]</span>
                  </div>
                  <div class="menu-list-item">
                    <span>Text Speed</span>
                    <span>[Coming Soon]</span>
                  </div>
                  <div class="menu-list-item">
                    <span>Auto-Save</span>
                    <span>[Coming Soon]</span>
                  </div>
                </div>
              </div>
              <div class="menu-card">
                <div class="menu-card-title">Controls</div>
                <div style="padding: 10px; font-size: 0.9em;">
                  <div>Movement: WASD or Arrow Keys</div>
                  <div>Interact: E or Enter</div>
                  <div>Menu: M or Escape</div>
                  <div>Debug: ~ (tilde)</div>
                </div>
              </div>
            `;
            break;
        }
      }
      
      useItem(itemId) {
        const player = this.partyMembers[this.partyIndex];
        if (!player) return;
        
        const result = player.useItem(itemId, player);
        if (result) {
          this.renderTab('inventory');
          // Show effect notification
          const itemData = ITEM_DATABASE[itemId];
          if (itemData) {
            this.showNotification(`Used ${itemData.name}!`);
          }
        }
      }
      
      selectQuest(index) {
        const quest = window.questManager?.activeQuests[index];
        if (!quest) return;
        
        this.selectedItem = quest;
        const detailContent = document.querySelector('.menu-detail-content');
        if (!detailContent) return;
        
        this.sidebar.style.display = '';
        detailContent.innerHTML = `
          <h3>${quest.name}</h3>
          <p style="color: #888; font-size: 0.9em;">From: ${quest.giver}</p>
          <p>${quest.description}</p>
          <div style="margin-top: 10px;">
            <h4>Objectives:</h4>
            ${quest.objectives.map(obj => `
              <div style="margin: 5px 0;">
                ${obj.current >= obj.required ? '✓' : '○'} 
                ${obj.type === 'defeat' ? 'Defeat' : 'Collect'} ${obj.target}: ${obj.current}/${obj.required}
              </div>
            `).join('')}
          </div>
          <div style="margin-top: 10px;">
            <h4>Rewards:</h4>
            ${quest.rewards.xp ? `<div>• ${quest.rewards.xp} XP</div>` : ''}
            ${quest.rewards.gold ? `<div>• ${quest.rewards.gold} Gold</div>` : ''}
            ${quest.rewards.items && quest.rewards.items.length > 0 ? 
              quest.rewards.items.map(item => `<div>• ${item.quantity}x ${ITEM_DATABASE[item.id]?.name || item.id}</div>`).join('') : ''
            }
          </div>
        `;
      }
      
      selectCompletedQuest(index) {
        const quest = window.questManager?.completedQuests[index];
        if (!quest) return;
        
        this.selectedItem = quest;
        const detailContent = document.querySelector('.menu-detail-content');
        if (!detailContent) return;
        
        this.sidebar.style.display = '';
        detailContent.innerHTML = `
          <h3>${quest.name}</h3>
          <p style="color: #888; font-size: 0.9em;">From: ${quest.giver}</p>
          <p>${quest.description}</p>
          <p style="color: #4f4; margin-top: 10px;">✓ Completed</p>
        `;
      }
      
      showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          bottom: 100px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          color: #0ff;
          padding: 10px 20px;
          border-radius: 5px;
          border: 1px solid #0ff;
          z-index: 10000;
          animation: fadeInOut 2s ease-out;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => notification.remove(), 2000);
      }
      
      allocateStat(stat, amount) {
        const player = window.game?.player?.character;
        if (!player) return;
        
        if (amount > 0 && player.statPoints > 0) {
          player.stats[stat] += 1;
          player.statPoints -= 1;
        } else if (amount < 0 && player.stats[stat] > player.baseStats[stat]) {
          player.stats[stat] -= 1;
          player.statPoints += 1;
        }
        
        player.calculateDerivedStats();
        this.renderTab('character');
      }
      
      confirmStatAllocation() {
        // In this simple version, just lock in the stats (could add more logic if needed)
        this.renderTab('character');
      }
    }

    // --- Initialize MenuManager and keyboard shortcut ---
    const menuManager = new MenuManager();
    document.getElementById('menu-close-btn').onclick = () => window.menuManager && window.menuManager.close();
    window.addEventListener('keydown', e => {
      window.debugLog && window.debugLog('keydown event: ' + e.key);
      console.log('keydown event:', e.key);
      const menuOverlay = document.getElementById('menu-overlay');
      window.debugLog && window.debugLog('menuOverlay open (every key): ' + menuOverlay.classList.contains('open'));
      // Toggle debug overlay with ~
      if (e.key === '`' || e.key === '~') {
        window.debugLog && window.debugLog('Entered debug overlay toggle block');
        debugVisible = !debugVisible;
        debugOverlay.style.display = debugVisible ? 'block' : 'none';
        updateDebugOverlay(e.key);
      }
      // Dev/test: '-' key gives Glitch Stick relic
      if (e.key === '-' && document.activeElement.tagName !== 'INPUT' && !menuOverlay.classList.contains('open')) {
        if (!window.gameReady) {
          window.debugLog && window.debugLog('Game not started yet: cannot give relic.');
          return;
        }
        window.debugLog && window.debugLog('Entered dev shortcut block');
        window.debugLog && window.debugLog('window.giveTestRelic: ' + (typeof window.giveTestRelic));
        window.debugLog && window.debugLog('window.game: ' + (typeof window.game));
        window.debugLog && window.debugLog('window.game?.player: ' + (window.game && window.game.player ? 'exists' : 'undefined'));
        window.debugLog && window.debugLog('window.game?.player?.character: ' + (window.game && window.game.player && window.game.player.character ? 'exists' : 'undefined'));
        console.log('window.giveTestRelic:', window.giveTestRelic);
        console.log('window.game:', window.game);
        console.log('window.game?.player:', window.game && window.game.player);
        console.log('window.game?.player?.character:', window.game && window.game.player && window.game.player.character);
        window.giveTestRelic && window.giveTestRelic();
        window.debugLog('Pressed - : called giveTestRelic()');
        updateDebugOverlay(e.key);
      }
      // Menu open/close logic
      if ((e.key === 'Escape' || e.key.toLowerCase() === 'm') && document.activeElement.tagName !== 'INPUT') {
        window.debugLog && window.debugLog('Entered menu open/close block');
        window.debugLog && window.debugLog('menuManager: ' + (typeof window.menuManager));
        window.debugLog && window.debugLog('menuOverlay open before: ' + menuOverlay.classList.contains('open'));
        console.log('menuManager:', window.menuManager);
        console.log('menuOverlay open before:', menuOverlay.classList.contains('open'));
        if (menuOverlay.classList.contains('open')) {
          window.menuManager && window.menuManager.close();
          window.debugLog('Menu closed via key');
        } else {
          window.menuManager && window.menuManager.open();
          window.debugLog('Menu opened via key');
        }
        window.debugLog && window.debugLog('menuOverlay open after: ' + menuOverlay.classList.contains('open'));
        console.log('menuOverlay open after:', menuOverlay.classList.contains('open'));
        updateDebugOverlay(e.key);
      }
      updateDebugOverlay(e.key);
    });

    // --- Add global handlers for relic actions ---
    window.useRelicAbility = function(relicId, abilityName) {
      const player = window.game?.player?.character;
      if (!player) return;
      const relic = player.relics[relicId];
      if (!relic) return;
      const ability = relic.abilities.find(a => a.name === abilityName);
      if (!ability) return;
      // Simple cooldown check (not persistent)
      const now = Date.now();
      if (ability.cooldown && ability.lastUsed && now - ability.lastUsed < ability.cooldown * 1000) {
        alert('Ability is on cooldown!');
        return;
      }
      ability.lastUsed = now;
      // Placeholder effect for Glitch Stick
      if (relicId === 'glitch_stick' && abilityName === 'Reality Glitch') {
        alert('Reality glitches! (Test effect)');
        gainRelicXP(relic, 5);
        menuManager.renderTab('relics');
      } else {
        alert(`Use ability '${abilityName}' from relic '${relicId}' (placeholder)`);
      }
    };
    window.equipRelic = function(relicId) {
      const player = window.game?.player?.character;
      if (!player) return;
      // Equip in first available slot
      if (!player.equipment.RELIC_1) player.equipment.RELIC_1 = player.relics[relicId];
      else if (!player.equipment.RELIC_2) player.equipment.RELIC_2 = player.relics[relicId];
      else player.equipment.RELIC_1 = player.relics[relicId]; // Replace slot 1 for now
      menuManager.renderTab('relics');
      menuManager.renderTab('equipment');
    };
    window.unequipRelic = function(relicId) {
      const player = window.game?.player?.character;
      if (!player) return;
      if (player.equipment.RELIC_1 && player.equipment.RELIC_1.id === relicId) player.equipment.RELIC_1 = null;
      if (player.equipment.RELIC_2 && player.equipment.RELIC_2.id === relicId) player.equipment.RELIC_2 = null;
      menuManager.renderTab('relics');
      menuManager.renderTab('equipment');
    };

    // --- Sample Relic: Glitch Stick ---
    const GLITCH_STICK = {
      id: 'glitch_stick',
      name: 'Glitch Stick',
      description: 'A mysterious stick that pulses with unstable code. Can disrupt reality for a moment.',
      level: 1,
      xp: 0,
      xpToNextLevel: 20,
      abilities: [
        {
          name: 'Reality Glitch',
          type: 'active',
          description: 'Causes a random glitch effect. (Test ability)',
          cooldown: 0,
          lastUsed: 0
        }
      ]
    };

    // --- Relic XP/Leveling ---
    function gainRelicXP(relic, amount) {
      relic.xp += amount;
      while (relic.xp >= relic.xpToNextLevel) {
        relic.xp -= relic.xpToNextLevel;
        relic.level++;
        relic.xpToNextLevel = Math.floor(relic.xpToNextLevel * 1.5 + 10);
        // Optionally: unlock new abilities, show message, etc.
      }
    }

    // --- Give Test Relic (for dev/testing only) ---
    window.giveTestRelic = function() {
      const player = window.game?.player?.character;
      if (!player) return;
      if (!player.relics[GLITCH_STICK.id]) {
        // Deep clone to avoid reference issues
        player.relics[GLITCH_STICK.id] = JSON.parse(JSON.stringify(GLITCH_STICK));
        menuManager.renderTab('relics');
      }
    };

    // --- Debug Overlay ---
    const debugOverlay = document.getElementById('debug-overlay');
    const debugContent = document.getElementById('debug-content');
    const debugCloseBtn = document.getElementById('debug-close-btn');
    let debugVisible = false;
    window.debugLog = function(msg) {
      if (!debugContent) return;
      const p = document.createElement('div');
      p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      debugContent.appendChild(p);
      debugContent.scrollTop = debugContent.scrollHeight;
    };
    function updateDebugOverlay(lastKey) {
      const menuOpen = document.getElementById('menu-overlay').classList.contains('open');
      const player = window.game?.player?.character;
      debugContent.innerHTML = `
        <b>Menu Open:</b> ${menuOpen}<br>
        <b>Last Key:</b> ${lastKey || ''}<br>
        <b>Relics:</b><br>
        <ul style="margin:0 0 8px 12px;">
          ${player ? Object.values(player.relics).map(r => `<li>${r.name} (id: ${r.id}, lvl: ${r.level}, xp: ${r.xp}/${r.xpToNextLevel})</li>`).join('') : '<li>None</li>'}
        </ul>
      `;
    }
    debugCloseBtn.onclick = () => { debugOverlay.style.display = 'none'; debugVisible = false; };

    // --- Combat System ---
    class CombatSystem {
      constructor(game) {
        this.game = game;
        this.inCombat = false;
        this.currentTurn = 0;
        this.turnOrder = [];
        this.participants = {};
        this.currentActor = null;
        this.battleLog = [];
        this.cosmicBalance = {
          harmony: 50,
          chaos: 50,
          stability: 50
        };
        this.activeCombos = [];
        this.selectedAction = null;
        this.targetingMode = false;
        this.selectedTargets = [];
        
        // Create combat UI container
        this.createCombatUI();
      }
      
      createCombatUI() {
        // Combat container
        this.combatContainer = document.createElement('div');
        this.combatContainer.id = 'combat-container';
        this.combatContainer.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: rgba(0, 0, 0, 0.95);
          display: none;
          z-index: 5000;
          color: #fff;
          font-family: 'Segoe UI', Arial, sans-serif;
        `;
        
        // Battle screen layout
        this.combatContainer.innerHTML = `
          <div id="combat-screen" style="width: 100%; height: 100%; display: flex; flex-direction: column;">
            <!-- Cosmic Balance Meter -->
            <div id="cosmic-balance" style="height: 40px; background: #111; display: flex; padding: 5px;">
              <div style="flex: 1; text-align: center;">
                <span style="color: #4f4;">Harmony: <span id="harmony-val">50</span>%</span>
              </div>
              <div style="flex: 1; text-align: center;">
                <span style="color: #f44;">Chaos: <span id="chaos-val">50</span>%</span>
              </div>
              <div style="flex: 1; text-align: center;">
                <span style="color: #44f;">Stability: <span id="stability-val">50</span>%</span>
              </div>
            </div>
            
            <!-- Turn Order -->
            <div id="turn-order" style="height: 60px; background: #222; display: flex; align-items: center; padding: 0 10px; gap: 10px; overflow-x: auto;">
              <!-- Turn order icons will go here -->
            </div>
            
            <!-- Battle Arena -->
            <div id="battle-arena" style="flex: 1; display: flex; flex-direction: column; padding: 20px;">
              <!-- Enemy Area -->
              <div id="enemy-area" style="flex: 1; display: flex; justify-content: center; align-items: center; gap: 20px;">
                <!-- Enemies will be rendered here -->
              </div>
              
              <!-- Party Area -->
              <div id="party-area" style="flex: 1; display: flex; justify-content: center; align-items: center; gap: 20px;">
                <!-- Party members will be rendered here -->
              </div>
            </div>
            
            <!-- Action Menu -->
            <div id="action-menu" style="height: 150px; background: #111; padding: 10px; display: flex; gap: 10px;">
              <div id="action-buttons" style="display: flex; flex-direction: column; gap: 5px;">
                <button class="combat-btn" onclick="window.combatSystem.selectAction('attack')">Attack</button>
                <button class="combat-btn" onclick="window.combatSystem.selectAction('skills')">Skills</button>
                <button class="combat-btn" onclick="window.combatSystem.selectAction('cosmic')">Cosmic</button>
                <button class="combat-btn" onclick="window.combatSystem.selectAction('items')">Items</button>
                <button class="combat-btn" onclick="window.combatSystem.selectAction('defend')">Defend</button>
              </div>
              <div id="action-submenu" style="flex: 1; background: #222; padding: 10px; overflow-y: auto;">
                <!-- Submenu content -->
              </div>
              <div id="battle-log" style="width: 300px; background: #222; padding: 10px; overflow-y: auto; font-size: 0.9em;">
                <!-- Battle messages -->
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(this.combatContainer);
        
        // Style combat buttons
        const style = document.createElement('style');
        style.textContent = `
          .combat-btn {
            background: #333;
            border: 1px solid #666;
            color: #fff;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
          }
          .combat-btn:hover {
            background: #444;
            border-color: #888;
          }
          .combat-btn:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
          }
          .combat-unit {
            background: #333;
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            min-width: 120px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
          }
          .combat-unit:hover {
            border-color: #0ff;
          }
          .combat-unit.selected {
            border-color: #ff0;
            box-shadow: 0 0 10px #ff0;
          }
          .combat-unit.current-turn {
            border-color: #0f0;
            box-shadow: 0 0 15px #0f0;
          }
          .hp-bar {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin: 4px 0;
          }
          .hp-fill {
            height: 100%;
            background: #4f4;
            transition: width 0.3s;
          }
          .mp-bar {
            width: 100%;
            height: 6px;
            background: #222;
            border-radius: 3px;
            overflow: hidden;
            margin: 2px 0;
          }
          .mp-fill {
            height: 100%;
            background: #44f;
            transition: width 0.3s;
          }
        `;
        document.head.appendChild(style);
      }
      
      startCombat(party, enemyTypes) {
        this.inCombat = true;
        this.turnOrder = [];
        this.battleLog = [];
        this.currentTurn = 0;
        
        // Show combat UI
        this.combatContainer.style.display = 'block';
        
        // Initialize enemies
        const enemies = enemyTypes.map(type => new Enemy(type));
        
        // Initialize participants
        this.participants = {};
        
        // Add party members
        party.forEach((member, idx) => {
          const id = member.id || `party_${idx}`;
          this.participants[id] = {
            ...member,
            type: 'player',
            side: 'party',
            position: idx,
            buffs: [],
            debuffs: [],
            statusEffects: []
          };
        });
        
        // Add enemies
        enemies.forEach((enemy, idx) => {
          this.participants[enemy.id] = {
            ...enemy,
            type: 'enemy',
            side: 'enemy',
            position: idx
          };
        });
        
        // Calculate initiative and sort turn order
        const allCombatants = Object.values(this.participants).map(p => ({
          id: p.id,
          initiative: this.rollInitiative(p),
          name: p.name
        }));
        
        this.turnOrder = allCombatants.sort((a, b) => b.initiative - a.initiative).map(c => c.id);
        
        // Update UI
        this.updateCombatUI();
        
        // Log battle start
        this.logBattle('Battle started!');
        
        // Start first turn
        this.nextTurn();
      }
      
      rollInitiative(combatant) {
        const baseSpeed = combatant.stats?.speed || combatant.derivedStats?.speed || 10;
        const d8 = Math.floor(Math.random() * 8) + 1;
        const levelBonus = Math.floor((combatant.level || 1) / 10);
        return baseSpeed + d8 + levelBonus;
      }
      
      nextTurn() {
        // Get next actor
        const currentIndex = this.turnOrder.findIndex(id => id === this.currentActor);
        const nextIndex = (currentIndex + 1) % this.turnOrder.length;
        this.currentActor = this.turnOrder[nextIndex];
        
        const actor = this.participants[this.currentActor];
        if (!actor || actor.hp <= 0) {
          this.nextTurn();
          return;
        }
        
        this.currentTurn++;
        this.selectedAction = null;
        this.targetingMode = false;
        this.selectedTargets = [];
        
        // Process start-of-turn effects
        this.processStartOfTurnEffects(actor);
        
        // Update UI
        this.updateCombatUI();
        
        // If enemy turn, execute AI
        if (actor.type === 'enemy') {
          setTimeout(() => this.executeEnemyTurn(actor), 1000);
        } else {
          // Enable action buttons for player turn
          this.enableActionButtons(true);
        }
      }
      
      executeEnemyTurn(enemy) {
        const party = Object.values(this.participants).filter(p => p.side === 'party' && p.hp > 0);
        const action = enemy.chooseAction(party);
        
        if (action.type === 'attack') {
          const damage = this.calculateDamage(enemy, action.target, 'physical');
          action.target.hp = Math.max(0, action.target.hp - damage);
          this.logBattle(`${enemy.name} attacks ${action.target.name} for ${damage} damage!`);
        } else if (action.type === 'ability') {
          this.executeAbility(enemy, action.ability, action.targets);
        }
        
        // Update UI and check for battle end
        this.updateCombatUI();
        
        if (this.checkBattleEnd()) {
          this.endBattle();
        } else {
          setTimeout(() => this.nextTurn(), 1500);
        }
      }
      
      calculateDamage(attacker, defender, type = 'physical') {
        const atk = type === 'physical' 
          ? (attacker.stats?.attack || attacker.derivedStats?.attack || 10)
          : (attacker.stats?.magic || attacker.derivedStats?.magic || 10);
        
        const def = type === 'physical'
          ? (defender.stats?.defense || defender.derivedStats?.defense || 5)
          : (defender.stats?.mDefense || defender.derivedStats?.mDefense || 5);
        
        const baseDamage = atk * 2;
        const reduction = (100 / (100 + def));
        let finalDamage = Math.floor(baseDamage * reduction);
        
        // Add some variance
        finalDamage = Math.floor(finalDamage * (0.9 + Math.random() * 0.2));
        
        return Math.max(1, finalDamage);
      }
      
      executeAbility(user, ability, targets) {
        this.logBattle(`${user.name} uses ${ability.name}!`);
        
        switch(ability.type) {
          case 'physical':
          case 'magical':
            targets.forEach(target => {
              const damage = Math.floor(this.calculateDamage(user, target, ability.type) * (ability.power || 1));
              target.hp = Math.max(0, target.hp - damage);
              this.logBattle(`${target.name} takes ${damage} damage!`);
            });
            break;
            
          case 'heal':
            targets.forEach(target => {
              const healing = Math.floor(target.maxHp * (ability.power || 0.3));
              target.hp = Math.min(target.maxHp, target.hp + healing);
              this.logBattle(`${target.name} heals ${healing} HP!`);
            });
            break;
            
          case 'buff':
          case 'debuff':
            targets.forEach(target => {
              // Apply buff/debuff
              const effect = {
                type: ability.effect,
                power: ability.power || 1.2,
                duration: ability.duration || 3,
                turnsRemaining: ability.duration || 3
              };
              
              if (ability.type === 'buff') {
                target.buffs.push(effect);
                this.logBattle(`${target.name}'s ${ability.effect} increased!`);
              } else {
                target.debuffs.push(effect);
                this.logBattle(`${target.name}'s ${ability.effect} decreased!`);
              }
            });
            break;
        }
      }
      
      selectAction(action) {
        this.selectedAction = action;
        const submenu = document.getElementById('action-submenu');
        
        if (action === 'attack') {
          this.targetingMode = true;
          submenu.innerHTML = '<p>Select target...</p>';
          this.updateCombatUI();
        } else if (action === 'defend') {
          const actor = this.participants[this.currentActor];
          actor.defending = true;
          this.logBattle(`${actor.name} defends!`);
          this.enableActionButtons(false);
          setTimeout(() => this.nextTurn(), 1000);
        } else if (action === 'skills') {
          const actor = this.participants[this.currentActor];
          const skills = actor.skills || [];
          submenu.innerHTML = skills.length > 0 
            ? skills.map((skill, idx) => `
                <div class="combat-btn" onclick="window.combatSystem.selectSkill(${idx})" style="margin-bottom: 5px;">
                  ${skill.name} (MP: ${skill.mpCost})
                </div>
              `).join('')
            : '<p>No skills available</p>';
        }
      }
      
      selectTarget(targetId) {
        if (!this.targetingMode || !this.selectedAction) return;
        
        if (this.selectedAction === 'attack') {
          const actor = this.participants[this.currentActor];
          const target = this.participants[targetId];
          
          const damage = this.calculateDamage(actor, target, 'physical');
          target.hp = Math.max(0, target.hp - damage);
          
          this.logBattle(`${actor.name} attacks ${target.name} for ${damage} damage!`);
          
          this.targetingMode = false;
          this.enableActionButtons(false);
          this.updateCombatUI();
          
          if (this.checkBattleEnd()) {
            this.endBattle();
          } else {
            setTimeout(() => this.nextTurn(), 1500);
          }
        }
      }
      
      processStartOfTurnEffects(actor) {
        // Process buffs/debuffs duration
        actor.buffs = actor.buffs.filter(buff => {
          buff.turnsRemaining--;
          if (buff.turnsRemaining <= 0) {
            this.logBattle(`${actor.name}'s ${buff.type} boost wore off.`);
            return false;
          }
          return true;
        });
        
        actor.debuffs = actor.debuffs.filter(debuff => {
          debuff.turnsRemaining--;
          if (debuff.turnsRemaining <= 0) {
            this.logBattle(`${actor.name} recovered from ${debuff.type} reduction.`);
            return false;
          }
          return true;
        });
      }
      
      checkBattleEnd() {
        const party = Object.values(this.participants).filter(p => p.side === 'party');
        const enemies = Object.values(this.participants).filter(p => p.side === 'enemy');
        
        const partyAlive = party.some(p => p.hp > 0);
        const enemiesAlive = enemies.some(e => e.hp > 0);
        
        return !partyAlive || !enemiesAlive;
      }
      
      endBattle() {
        const party = Object.values(this.participants).filter(p => p.side === 'party');
        const enemies = Object.values(this.participants).filter(p => p.side === 'enemy');
        
        const victory = party.some(p => p.hp > 0);
        
        if (victory) {
          this.logBattle('Victory!');
          
          // Calculate rewards
          let totalXP = 0;
          let totalGold = 0;
          const drops = [];
          const defeatedEnemies = [];
          
          enemies.forEach(enemy => {
            totalXP += enemy.xpReward || 0;
            totalGold += enemy.goldReward || 0;
            
            if (enemy.rollDrops) {
              const enemyDrops = enemy.rollDrops();
              drops.push(...enemyDrops);
            }
            
            // Track defeated enemies for quests
            defeatedEnemies.push(enemy.enemyId);
          });
          
          // Apply rewards to party
          party.forEach(member => {
            const char = member.character || member;
            if (char.hp > 0) {
              // Check for level up
              const oldLevel = char.level;
              char.gainExperience(totalXP);
              if (char.level > oldLevel) {
                this.logBattle(`${char.name} leveled up to ${char.level}!`);
              }
              
              char.gold += Math.floor(totalGold / party.filter(p => p.hp > 0).length);
              
              // Add dropped items
              drops.forEach(drop => {
                char.addItem(drop.item.toLowerCase().replace(/ /g, '_'), drop.quantity);
              });
            }
          });
          
          // Update quest progress
          defeatedEnemies.forEach(enemyId => {
            this.game.questManager.updateQuestProgress('defeat', enemyId, 1);
          });
          
          // Show rewards
          setTimeout(() => {
            let rewardText = `Victory!\nGained ${totalXP} XP and ${totalGold} gold!`;
            if (drops.length > 0) {
              rewardText += '\n\nItems obtained:';
              drops.forEach(drop => {
                rewardText += `\n• ${drop.item} x${drop.quantity}`;
              });
            }
            alert(rewardText);
            this.closeCombat();
          }, 1000);
          
        } else {
          this.logBattle('Defeat...');
          setTimeout(() => {
            alert('Game Over!');
            location.reload(); // Simple game over for now
          }, 1000);
        }
      }
      
      closeCombat() {
        this.inCombat = false;
        this.combatContainer.style.display = 'none';
        this.game.resumeFromCombat();
      }
      
      enableActionButtons(enabled) {
        const buttons = document.querySelectorAll('#action-buttons .combat-btn');
        buttons.forEach(btn => btn.disabled = !enabled);
      }
      
      updateCombatUI() {
        // Update turn order display
        const turnOrderDiv = document.getElementById('turn-order');
        turnOrderDiv.innerHTML = this.turnOrder.map((id, idx) => {
          const participant = this.participants[id];
          if (!participant || participant.hp <= 0) return '';
          
          const isCurrent = id === this.currentActor;
          return `
            <div class="combat-unit ${isCurrent ? 'current-turn' : ''}" style="padding: 5px 10px; font-size: 0.9em;">
              ${participant.name}
            </div>
          `;
        }).join('');
        
        // Update enemy area
        const enemyArea = document.getElementById('enemy-area');
        const enemies = Object.values(this.participants).filter(p => p.side === 'enemy');
        enemyArea.innerHTML = enemies.map(enemy => `
          <div class="combat-unit ${this.targetingMode && enemy.hp > 0 ? 'targetable' : ''}" 
               onclick="window.combatSystem.selectTarget('${enemy.id}')"
               style="${enemy.hp <= 0 ? 'opacity: 0.3;' : ''}">
            <div style="font-weight: bold;">${enemy.name}</div>
            <div style="font-size: 0.8em; color: #aaa;">${enemy.type} Lv.${enemy.level}</div>
            <div class="hp-bar">
              <div class="hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%"></div>
            </div>
            <div style="font-size: 0.8em;">${enemy.hp}/${enemy.maxHp} HP</div>
          </div>
        `).join('');
        
        // Update party area
        const partyArea = document.getElementById('party-area');
        const party = Object.values(this.participants).filter(p => p.side === 'party');
        partyArea.innerHTML = party.map(member => {
          const char = member.character || member;
          const isCurrent = member.id === this.currentActor;
          return `
            <div class="combat-unit ${isCurrent ? 'current-turn' : ''}" 
                 style="${char.hp <= 0 ? 'opacity: 0.3;' : ''}">
              <div style="font-weight: bold;">${char.name}</div>
              <div style="font-size: 0.8em; color: #aaa;">${char.class} Lv.${char.level}</div>
              <div class="hp-bar">
                <div class="hp-fill" style="width: ${(char.hp / char.maxHp) * 100}%"></div>
              </div>
              <div style="font-size: 0.8em;">${char.hp}/${char.maxHp} HP</div>
              <div class="mp-bar">
                <div class="mp-fill" style="width: ${(char.mp / char.maxMp) * 100}%"></div>
              </div>
              <div style="font-size: 0.8em;">${char.mp}/${char.maxMp} MP</div>
            </div>
          `;
        }).join('');
        
        // Update cosmic balance
        document.getElementById('harmony-val').textContent = this.cosmicBalance.harmony;
        document.getElementById('chaos-val').textContent = this.cosmicBalance.chaos;
        document.getElementById('stability-val').textContent = this.cosmicBalance.stability;
      }
      
      logBattle(message) {
        this.battleLog.push(message);
        const logDiv = document.getElementById('battle-log');
        logDiv.innerHTML = this.battleLog.slice(-20).map(msg => `<div style="margin-bottom: 4px;">${msg}</div>`).join('');
        logDiv.scrollTop = logDiv.scrollHeight;
      }
    }

    // --- Start Game ---
    function startGame() {
      window.debugLog && window.debugLog('startGame() called');
      document.getElementById('start-overlay').classList.add('hidden');
      setTimeout(() => {
        document.getElementById('start-overlay').style.display = 'none';
        window.game = new Game();
        window.gameReady = true;
        // Initialize MenuManager after game is ready
        if (!window.menuManager) {
          window.menuManager = new MenuManager();
        }
        // Set up party members (for now, just the player character)
        window.menuManager.partyMembers = [window.game.player.character];
        window.menuManager.partyIndex = 0;
        window.menuManager.updatePartyNav();
        window.debugLog && window.debugLog('Game started: window.game is set. MenuManager initialized.');
      }, 350);
    }
    window.addEventListener('load', () => {
      const startBtn = document.getElementById('start-btn');
      if (startBtn) {
        startBtn.onclick = startGame;
        window.debugLog && window.debugLog('startBtn.onclick set');
      }
      // Start with cutscene
      const cutscene = new CutsceneManager(() => {});
      cutscene.play(introCutscene);
    });

    // --- Item System ---
    const ITEM_DATABASE = {
      // Consumables
      'potion': {
        name: 'Potion',
        type: 'consumable',
        description: 'Restores 50 HP',
        effect: { type: 'heal', value: 50, target: 'single' },
        stackable: true,
        maxStack: 99,
        value: 50
      },
      'ether': {
        name: 'Ether',
        type: 'consumable',
        description: 'Restores 30 MP',
        effect: { type: 'restore_mp', value: 30, target: 'single' },
        stackable: true,
        maxStack: 99,
        value: 100
      },
      'phoenix_down': {
        name: 'Phoenix Down',
        type: 'consumable',
        description: 'Revives a fallen ally with 25% HP',
        effect: { type: 'revive', value: 0.25, target: 'single' },
        stackable: true,
        maxStack: 20,
        value: 300
      },
      
      // Materials (from enemy drops)
      'bug_shell': {
        name: 'Bug Shell',
        type: 'material',
        description: 'A shiny shell from a digital bug',
        stackable: true,
        maxStack: 999,
        value: 5
      },
      'spam_mail': {
        name: 'Spam Mail',
        type: 'material',
        description: 'Unwanted digital correspondence',
        stackable: true,
        maxStack: 999,
        value: 8
      },
      'yeti_fur': {
        name: 'Yeti Fur',
        type: 'material',
        description: 'Warm fur from a WiFi Yeti',
        stackable: true,
        maxStack: 999,
        value: 10
      },
      'sticky_residue': {
        name: 'Sticky Residue',
        type: 'material',
        description: 'Gross but useful crafting material',
        stackable: true,
        maxStack: 999,
        value: 3
      },
      'frost_shard': {
        name: 'Frost Shard',
        type: 'material',
        description: 'A frozen fragment of digital ice',
        stackable: true,
        maxStack: 999,
        value: 15
      },
      
      // Equipment
      'frozen_core': {
        name: 'Frozen Core',
        type: 'accessory',
        description: 'Increases ice damage by 5%',
        stats: { iceDamage: 5 },
        value: 200
      },
      'golden_ticket': {
        name: 'Golden Ticket',
        type: 'key_item',
        description: 'Unlocks access to a special shop',
        stackable: false,
        value: 0
      }
    };

    // --- Quest System ---
    const QUEST_DATABASE = {
      'tutorial_combat': {
        id: 'tutorial_combat',
        name: 'Welcome to the Glitch',
        giver: 'Glitch',
        description: "I'm Glitch, your... guide? Assistant? Look, I don't remember exactly. But I know you need to learn how to fight. Defeat 3 Roaches.",
        objectives: [
          { type: 'defeat', target: 'roach', required: 3, current: 0 }
        ],
        rewards: {
          xp: 50,
          gold: 100,
          items: [{ id: 'potion', quantity: 3 }]
        },
        dialogue: {
          start: "Hey there, fresh meat. Name's Glitch. I'm supposed to help you or something. Memory's a bit fuzzy. Let's start with the basics - go squash some bugs. Literally.",
          progress: "Still alive? Good. Keep hunting those Roaches. They're annoying but manageable.",
          complete: "Not bad for a newbie. Here, take these potions. You'll need them. Trust me on that... I think."
        }
      },
      'find_memory_fragment': {
        id: 'find_memory_fragment',
        name: 'Fragmented Memories',
        giver: 'Glitch',
        description: "I keep having these... flashes. There's something important I'm forgetting. Help me find Memory Fragments scattered around.",
        objectives: [
          { type: 'collect', target: 'memory_fragment', required: 1, current: 0 }
        ],
        rewards: {
          xp: 100,
          gold: 200,
          items: []
        },
        dialogue: {
          start: "Something's wrong with my memory banks. I know there's more to this place than meets the eye. Find me a Memory Fragment - they look like glowing shards.",
          progress: "Any luck? These fragments... they're pieces of something bigger. Something important.",
          complete: "This fragment... I remember now! Well, part of it. We're not supposed to be here. None of us are. There's more to find."
        }
      }
    };

    class QuestManager {
      constructor() {
        this.activeQuests = [];
        this.completedQuests = [];
        this.questProgress = {};
      }
      
      startQuest(questId) {
        if (this.activeQuests.find(q => q.id === questId)) return;
        
        const questData = QUEST_DATABASE[questId];
        if (!questData) return;
        
        const quest = {
          ...questData,
          startTime: Date.now(),
          objectives: questData.objectives.map(obj => ({ ...obj }))
        };
        
        this.activeQuests.push(quest);
        this.showQuestNotification('New Quest: ' + quest.name);
      }
      
      updateQuestProgress(type, target, amount = 1) {
        let updated = false;
        
        this.activeQuests.forEach(quest => {
          quest.objectives.forEach(obj => {
            if (obj.type === type && obj.target === target && obj.current < obj.required) {
              obj.current = Math.min(obj.current + amount, obj.required);
              updated = true;
              
              if (obj.current >= obj.required) {
                this.checkQuestCompletion(quest);
              }
            }
          });
        });
        
        if (updated) {
          this.showQuestNotification('Quest progress updated!');
        }
      }
      
      checkQuestCompletion(quest) {
        const allComplete = quest.objectives.every(obj => obj.current >= obj.required);
        
        if (allComplete) {
          this.completeQuest(quest);
        }
      }
      
      completeQuest(quest) {
        // Remove from active
        this.activeQuests = this.activeQuests.filter(q => q.id !== quest.id);
        
        // Add to completed
        quest.completedTime = Date.now();
        this.completedQuests.push(quest);
        
        // Give rewards
        const player = window.game?.player?.character;
        if (player && quest.rewards) {
          if (quest.rewards.xp) player.gainExperience(quest.rewards.xp);
          if (quest.rewards.gold) player.gold += quest.rewards.gold;
          if (quest.rewards.items) {
            quest.rewards.items.forEach(item => {
              player.addItem(item.id, item.quantity);
            });
          }
        }
        
        this.showQuestNotification('Quest Complete: ' + quest.name);
      }
      
      showQuestNotification(message) {
        // Simple notification for now
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 100px;
          right: 20px;
          background: rgba(0, 255, 255, 0.9);
          color: #000;
          padding: 10px 20px;
          border-radius: 5px;
          font-family: 'Courier New', monospace;
          z-index: 10000;
          animation: slideIn 0.3s ease-out;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.animation = 'slideOut 0.3s ease-out';
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }
    }

    // --- Glitch NPC ---
    class GlitchNPC {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.name = "Glitch";
        this.dialogue = [
          "Name's Glitch. I'm your... assistant? Guide? Something like that.",
          "My memory's shot to hell, but I know this place isn't right.",
          "Galaxander's got us all trapped here. You're gonna help me remember why.",
          "Find Memory Fragments. They're scattered all over. Each one brings back... something.",
          "Don't trust the shiny prizes. Nothing here is what it seems."
        ];
        this.currentDialogue = 0;
        this.memoryFragments = 0;
      }
      
      interact() {
        const questManager = window.game?.questManager;
        
        // Start tutorial quest if not started
        if (questManager && !questManager.activeQuests.find(q => q.id === 'tutorial_combat') && 
            !questManager.completedQuests.find(q => q.id === 'tutorial_combat')) {
          questManager.startQuest('tutorial_combat');
          this.showDialogue(QUEST_DATABASE.tutorial_combat.dialogue.start);
        } else {
          // Show regular dialogue
          this.showDialogue(this.dialogue[this.currentDialogue]);
          this.currentDialogue = (this.currentDialogue + 1) % this.dialogue.length;
        }
      }
      
      showDialogue(text) {
        // Create dialogue box
        const dialogueBox = document.createElement('div');
        dialogueBox.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.9);
          border: 2px solid #0ff;
          color: #0ff;
          padding: 20px;
          max-width: 600px;
          font-family: 'Courier New', monospace;
          z-index: 10000;
          border-radius: 5px;
        `;
        dialogueBox.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 10px; color: #fff;">${this.name}:</div>
          <div>${text}</div>
          <div style="text-align: right; margin-top: 10px; font-size: 0.8em; opacity: 0.7;">Press any key to continue</div>
        `;
        document.body.appendChild(dialogueBox);
        
        const closeDialogue = (e) => {
          dialogueBox.remove();
          window.removeEventListener('keydown', closeDialogue);
          window.removeEventListener('click', closeDialogue);
        };
        
        window.addEventListener('keydown', closeDialogue);
        window.addEventListener('click', closeDialogue);
      }
    }

    // Update Character class to handle inventory
    Character.prototype.addItem = function(itemId, quantity = 1) {
      const itemData = ITEM_DATABASE[itemId];
      if (!itemData) return false;
      
      // Find existing stack
      let existingItem = this.inventory.find(item => item.id === itemId);
      
      if (existingItem && itemData.stackable) {
        existingItem.quantity = Math.min(existingItem.quantity + quantity, itemData.maxStack);
      } else if (!existingItem) {
        this.inventory.push({
          id: itemId,
          name: itemData.name,
          type: itemData.type,
          description: itemData.description,
          quantity: quantity,
          stackable: itemData.stackable,
          value: itemData.value
        });
      }
      
      return true;
    };

    Character.prototype.removeItem = function(itemId, quantity = 1) {
      const itemIndex = this.inventory.findIndex(item => item.id === itemId);
      if (itemIndex === -1) return false;
      
      const item = this.inventory[itemIndex];
      if (item.quantity > quantity) {
        item.quantity -= quantity;
      } else {
        this.inventory.splice(itemIndex, 1);
      }
      
      return true;
    };

    Character.prototype.useItem = function(itemId, target = null) {
      const itemData = ITEM_DATABASE[itemId];
      if (!itemData || itemData.type !== 'consumable') return false;
      
      if (!this.removeItem(itemId, 1)) return false;
      
      // Apply item effect
      const effect = itemData.effect;
      switch(effect.type) {
        case 'heal':
          const healTarget = target || this;
          healTarget.hp = Math.min(healTarget.maxHp, healTarget.hp + effect.value);
          break;
        case 'restore_mp':
          const mpTarget = target || this;
          mpTarget.mp = Math.min(mpTarget.maxMp, mpTarget.mp + effect.value);
          break;
        case 'revive':
          if (target && target.hp <= 0) {
            target.hp = Math.floor(target.maxHp * effect.value);
          }
          break;
      }
      
      return true;
    };
  </script>
</body>
</html>
